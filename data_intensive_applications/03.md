# 03장 저장소와 검색

특정 workload 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 알아야 할 필요가 있다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- append only 데이터 파일 log
  - 여기서의 로그는 일반적인 의미로 연속된 추가 전용 레코드이다. 로그는 사람이 읽을 수 없는 바이너리 형식일 수도 있다.
- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 색인이 필요하다.
  - 색인은 부가적인 메타데이터를 유지하여 원하는 데이터의 위치를 찾는데 도움을 주는 이정표 역할을 한다.
  - 동일한 데이터를 여러 방법으로 찾고 싶다면 다양한 색인이 필요하다.
- 색인은 기본 데이터에서 파생된 추가적인 구조이다. 색인의 추가와 삭제는 데이터베이스의 내용에는 영향을 끼치지는 않지만 성능에는 영향을 끼친다.
  - 색인을 쓰는 과정에서 오버헤드가 발생하고, 데이터를 쓸 때 마다 색인을 갱신해야 하기 때문이다.
- 색인은 저장소 시스템의 중요한 트레이드 오프이다. 따라서 개발자와 데이터베이스 관리자는 전형적인 질의 패턴에 대한 지식을 활용해 수동ㅇ으로 색인을 선택해야 한다.

### 해시색인

- K-V 데이터는 매우 일반적이고 더욱 복잡한 색인을 위한 구성요소로 유용하다.
- K-V 저장소는 대부분의 프로그래밍 언어에 존재하는 dictionary type과 유사하다. 디스크상의 데이터를 색인하기 위해 인메모리 데이터 구조인 해시맵을 사용해보면 어떨까?
  - 키를 데이터 파일의 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략을 가질 수 있다. 
  - 파일에 새로운 K-V 쌍을 추가할 때 마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다. 
  - 값을 조회하려면 해시 맵을 사용해 데이터파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
- 이 방법은 단순해보이지만 실제로 많이 사용된다. Bitcask(Riak의 기본 저장소 엔진)이 근본적으로 사용하는 방식이다. 
  - Bitcask는 해시 맵을 전무 메모리에 유지하여 RAM에 모든 키가 저장된다는 것을 전제 조건으로 고성능의 읽기/쓰기를 보장한다. 
  - 이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다. 쓰기가 아주 많지만 고유키가 많지 않은 경우에 유용하다. 즉, 키당 쓰기 수가 많지만 메모리에 모든 키를 보관할 수 있다.
- 지금 설명한대로 항상 디스크에 파일을 추가하다보면 결국 디스크 공간이 부족해진다. 이 상황은 특정 크기의 segment로 로그를 나누어 해결할 수 있다. 특정 크기에 도달했을 때 세그먼트 파일을 닫고 새로운 세그먼트에 이후 쓰기를 수행한다. 세그먼트에 대해 컴팩션을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.