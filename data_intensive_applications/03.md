# 03장 저장소와 검색

특정 workload 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 알아야 할 필요가 있다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- append only 데이터 파일 log
  - 여기서의 로그는 일반적인 의미로 연속된 추가 전용 레코드이다. 로그는 사람이 읽을 수 없는 바이너리 형식일 수도 있다.
- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 색인이 필요하다.
  - 색인은 부가적인 메타데이터를 유지하여 원하는 데이터의 위치를 찾는데 도움을 주는 이정표 역할을 한다.
  - 동일한 데이터를 여러 방법으로 찾고 싶다면 다양한 색인이 필요하다.
- 색인은 기본 데이터에서 파생된 추가적인 구조이다. 색인의 추가와 삭제는 데이터베이스의 내용에는 영향을 끼치지는 않지만 성능에는 영향을 끼친다.
  - 색인을 쓰는 과정에서 오버헤드가 발생하고, 데이터를 쓸 때 마다 색인을 갱신해야 하기 때문이다.
- 색인은 저장소 시스템의 중요한 트레이드 오프이다. 따라서 개발자와 데이터베이스 관리자는 전형적인 질의 패턴에 대한 지식을 활용해 수동ㅇ으로 색인을 선택해야 한다.

### 해시색인

- K-V 데이터는 매우 일반적이고 더욱 복잡한 색인을 위한 구성요소로 유용하다.
- K-V 저장소는 대부분의 프로그래밍 언어에 존재하는 dictionary type과 유사하다. 디스크상의 데이터를 색인하기 위해 인메모리 데이터 구조인 해시맵을 사용해보면 어떨까?
  - 키를 데이터 파일의 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략을 가질 수 있다. 
  - 파일에 새로운 K-V 쌍을 추가할 때 마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다. 
  - 값을 조회하려면 해시 맵을 사용해 데이터파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
- 이 방법은 단순해보이지만 실제로 많이 사용된다. Bitcask(Riak의 기본 저장소 엔진)이 근본적으로 사용하는 방식이다. 
  - Bitcask는 해시 맵을 전무 메모리에 유지하여 RAM에 모든 키가 저장된다는 것을 전제 조건으로 고성능의 읽기/쓰기를 보장한다. 
  - 이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다. 쓰기가 아주 많지만 고유키가 많지 않은 경우에 유용하다. 즉, 키당 쓰기 수가 많지만 메모리에 모든 키를 보관할 수 있다.
- 지금 설명한대로 항상 디스크에 파일을 추가하다보면 결국 디스크 공간이 부족해진다. 이 상황은 특정 크기의 segment로 로그를 나누어 해결할 수 있다. 특정 크기에 도달했을 때 세그먼트 파일을 닫고 새로운 세그먼트에 이후 쓰기를 수행한다. 세그먼트에 대해 컴팩션을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.
- 컴팩션은 보통 세그먼트를 더 작게 만들어 동시에 여러 세그먼트를 합칠 수 있다. 세그먼트는 쓰여진 이후에 절대로 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만든다. 고정된 세그먼트의 병합과 컴팩션은 백그라운드에서 수행될 수 있고, 컴팩션이 수행되는 동안 이전 세그먼트 파일을 사용하여 읽기와 쓰기 요청을 정상적으로 처리할 수 있다. 병합이 끝난 이후 읽기 요청은 이전 세그먼트 대신 새로 병합된 세그먼트 파일을 사용하도록 전환한다. 전환 후에는 이전 세그먼트 파일을 간단히 삭제 한다.
- 이제 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다. 키의 값을 찾으려면 최신 세그먼트 해시 맵을 먼저 확인하고, 키가 없을 경우 두 번째, 세번째 최신 세그먼트를 확인한다. 병합 과정을 통해 세그먼트 수를 적게 유지하여 조회할 때 많은 해시 맵을 확인할 필요가 없다.
- 하지만 이런 간단한 생각을 구현하기 위해서는 실제로 많은 사항을 고려해야 한다. 예를 들면 다음과 같다.
  - 파일 형식
  - 레코드 삭제
  - Crash 복구
    - DB 재시작시 인메모리 해시맵은 손실된다. 복구하려면 전체 세그먼트 파일을 읽어 각 키에 대한 최신 값으로 해시맵을 복원할 수 있지만, 세그먼트 파일이 큰 경우 복원이 오래 걸릴 수 있다.
  - 부분적으로 레코드 쓰기
  - 동시성 제어
    - 쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적인 구현 방법은 하나의 쓰기 쓰레드만 사용하는 것이다. 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기를 할 수 있다.
- 해시 테이블 색인의 제한 사항
  - 해시 테이블을 메모리에 저장해야 하기 때문에 키가 너무 많을 경우 문제가 된다.
  - range query에 효율적이지 않다. 예를 들어 `kitty0000`과 `kitty9999`  사이 모든 키를 쉽게 스캔 할 수 없다. 해시 맵에서 모든 개별 키를 조회해야 한다.
  - 다음에서 이러한 제한이 없는 색인 구조를 살펴보자

### SS테이블과 LSM 트리

- Sorted String Table (SST, SS테이블)
  - 세그먼트 파일이 키로 정렬된 형식
  - 각 키는 병합된 세그먼트 파일에 반드시 한 번만 나타나야 한다. (컴팩션 과정은 이를 이미 보장한다.)
- SST는 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.
  - 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. 이 방법은 mergesort와 유사하다.
  - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다. 일부 키에 대한 오프셋을 알려주는 인메모리 색인이 여전히 필요하지만 색인 내용이 드문드문 희소할 수 있다.
  - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다. 그러면 희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 된다. 디스크 공간을 절약한다는 점 외에도 압축은 I/O 대역폭 사용도 줄인다.

#### SS테이블 생성과 유지

- Red Black Tree나 AVL 트리와 같은 잘 알려진 구조를 이용하여 정렬된 메모리를 유지 할 수 있다. 이런 데이터 구조를 이용하여 임의 순서로 키를 삽입하고 정렬된 순서로 키를 다시 읽을 수 있다.
- 이제 저장소 엔진을 다음과 같이 만들 수 있다.
  - 쓰기 발생시 인메모리 balanced tree 데이터 구조에 추가한다. 이 인메모리 balanced tree를 memtable이라고도 한다.
  - memtable이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS 테이블 파일로 디스크에 기록한다. 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록한다.
  - 읽기 요청을 제공할 때 먼저 멤테이블에서 키를 찾고 그 다음 디스크 상의 가장 최신 세그먼트에서 찾는다. 그 다음으로 두번째, 세번째 세그먼트 등에서 찾는다.
  - 가끕 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다.
- 위 계획은 데이터베이스가 고장났을 때 멤테이블에 존재하지만 디스크에 기록되지 않은 쓰기가 손실된다는 문제가 있다. 이런 문제를 피하기 위해 매번 쓰기를 즉시 추가할 수 있는 분리된 로그를 디스크 상에 유지해야 한다. 이 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 정렬되지 않아도 괜찮다. 멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.

