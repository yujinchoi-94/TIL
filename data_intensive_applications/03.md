# 03장 저장소와 검색

특정 workload 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 알아야 할 필요가 있다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- append only 데이터 파일 log
  - 여기서의 로그는 일반적인 의미로 연속된 추가 전용 레코드이다. 로그는 사람이 읽을 수 없는 바이너리 형식일 수도 있다.
- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 색인이 필요하다.
  - 색인은 부가적인 메타데이터를 유지하여 원하는 데이터의 위치를 찾는데 도움을 주는 이정표 역할을 한다.
  - 동일한 데이터를 여러 방법으로 찾고 싶다면 다양한 색인이 필요하다.
- 색인은 기본 데이터에서 파생된 추가적인 구조이다. 색인의 추가와 삭제는 데이터베이스의 내용에는 영향을 끼치지는 않지만 성능에는 영향을 끼친다.
  - 색인을 쓰는 과정에서 오버헤드가 발생하고, 데이터를 쓸 때 마다 색인을 갱신해야 하기 때문이다.
- 색인은 저장소 시스템의 중요한 트레이드 오프이다. 따라서 개발자와 데이터베이스 관리자는 전형적인 질의 패턴에 대한 지식을 활용해 수동ㅇ으로 색인을 선택해야 한다.

### 해시색인

- K-V 데이터는 매우 일반적이고 더욱 복잡한 색인을 위한 구성요소로 유용하다.
- K-V 저장소는 대부분의 프로그래밍 언어에 존재하는 dictionary type과 유사하다. 디스크상의 데이터를 색인하기 위해 인메모리 데이터 구조인 해시맵을 사용해보면 어떨까?
  - 키를 데이터 파일의 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략을 가질 수 있다. 
  - 파일에 새로운 K-V 쌍을 추가할 때 마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다. 
  - 값을 조회하려면 해시 맵을 사용해 데이터파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
- 이 방법은 단순해보이지만 실제로 많이 사용된다. Bitcask(Riak의 기본 저장소 엔진)이 근본적으로 사용하는 방식이다. 
  - Bitcask는 해시 맵을 전무 메모리에 유지하여 RAM에 모든 키가 저장된다는 것을 전제 조건으로 고성능의 읽기/쓰기를 보장한다. 
  - 이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다. 쓰기가 아주 많지만 고유키가 많지 않은 경우에 유용하다. 즉, 키당 쓰기 수가 많지만 메모리에 모든 키를 보관할 수 있다.
- 지금 설명한대로 항상 디스크에 파일을 추가하다보면 결국 디스크 공간이 부족해진다. 이 상황은 특정 크기의 segment로 로그를 나누어 해결할 수 있다. 특정 크기에 도달했을 때 세그먼트 파일을 닫고 새로운 세그먼트에 이후 쓰기를 수행한다. 세그먼트에 대해 컴팩션을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.
- 컴팩션은 보통 세그먼트를 더 작게 만들어 동시에 여러 세그먼트를 합칠 수 있다. 세그먼트는 쓰여진 이후에 절대로 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만든다. 고정된 세그먼트의 병합과 컴팩션은 백그라운드에서 수행될 수 있고, 컴팩션이 수행되는 동안 이전 세그먼트 파일을 사용하여 읽기와 쓰기 요청을 정상적으로 처리할 수 있다. 병합이 끝난 이후 읽기 요청은 이전 세그먼트 대신 새로 병합된 세그먼트 파일을 사용하도록 전환한다. 전환 후에는 이전 세그먼트 파일을 간단히 삭제 한다.
- 이제 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다. 키의 값을 찾으려면 최신 세그먼트 해시 맵을 먼저 확인하고, 키가 없을 경우 두 번째, 세번째 최신 세그먼트를 확인한다. 병합 과정을 통해 세그먼트 수를 적게 유지하여 조회할 때 많은 해시 맵을 확인할 필요가 없다.
- 하지만 이런 간단한 생각을 구현하기 위해서는 실제로 많은 사항을 고려해야 한다. 예를 들면 다음과 같다.
  - 파일 형식
  - 레코드 삭제
  - Crash 복구
    - DB 재시작시 인메모리 해시맵은 손실된다. 복구하려면 전체 세그먼트 파일을 읽어 각 키에 대한 최신 값으로 해시맵을 복원할 수 있지만, 세그먼트 파일이 큰 경우 복원이 오래 걸릴 수 있다.
  - 부분적으로 레코드 쓰기
  - 동시성 제어
    - 쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적인 구현 방법은 하나의 쓰기 쓰레드만 사용하는 것이다. 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기를 할 수 있다.
- 해시 테이블 색인의 제한 사항
  - 해시 테이블을 메모리에 저장해야 하기 때문에 키가 너무 많을 경우 문제가 된다.
  - range query에 효율적이지 않다. 예를 들어 `kitty0000`과 `kitty9999`  사이 모든 키를 쉽게 스캔 할 수 없다. 해시 맵에서 모든 개별 키를 조회해야 한다.
  - 다음에서 이러한 제한이 없는 색인 구조를 살펴보자

### SS테이블과 LSM 트리

- Sorted String Table (SST, SS테이블)
  - 세그먼트 파일이 키로 정렬된 형식
  - 각 키는 병합된 세그먼트 파일에 반드시 한 번만 나타나야 한다. (컴팩션 과정은 이를 이미 보장한다.)
- SST는 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.
  - 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. 이 방법은 mergesort와 유사하다.
  - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다. 일부 키에 대한 오프셋을 알려주는 인메모리 색인이 여전히 필요하지만 색인 내용이 드문드문 희소할 수 있다.
  - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다. 그러면 희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 된다. 디스크 공간을 절약한다는 점 외에도 압축은 I/O 대역폭 사용도 줄인다.

#### SS테이블 생성과 유지

- Red Black Tree나 AVL 트리와 같은 잘 알려진 구조를 이용하여 정렬된 메모리를 유지 할 수 있다. 이런 데이터 구조를 이용하여 임의 순서로 키를 삽입하고 정렬된 순서로 키를 다시 읽을 수 있다.
- 이제 저장소 엔진을 다음과 같이 만들 수 있다.
  - 쓰기 발생시 인메모리 balanced tree 데이터 구조에 추가한다. 이 인메모리 balanced tree를 memtable이라고도 한다.
  - memtable이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS 테이블 파일로 디스크에 기록한다. 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록한다.
  - 읽기 요청을 제공할 때 먼저 멤테이블에서 키를 찾고 그 다음 디스크 상의 가장 최신 세그먼트에서 찾는다. 그 다음으로 두번째, 세번째 세그먼트 등에서 찾는다.
  - 가끕 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다.
- 위 계획은 데이터베이스가 고장났을 때 멤테이블에 존재하지만 디스크에 기록되지 않은 쓰기가 손실된다는 문제가 있다. 이런 문제를 피하기 위해 매번 쓰기를 즉시 추가할 수 있는 분리된 로그를 디스크 상에 유지해야 한다. 이 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 정렬되지 않아도 괜찮다. 멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.

#### SS테이블에서 LSM 트리 만들기

- 이 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree)(AKA LSM Tree) 란 이름으로 발표됐다. 이 색인 구조는 로그 구조화 파일 시스템의 초기 작업 기반이 됐다.
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다.
- 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진 루씬은 용어 사전을 저장하기 위해 이와 유사한 방법을 사용한다.
  - 키를 단어(용어)로, 값은 단어를 포함한 모든 문서의 ID 목록으로 하는 키-값 구조로 표현한다. 루씬에서 용어와 포스팅의 목록은 SS테이블 같은 정렬 파일에 유지하고 필요에 따라 백그라운드에서 병합한다.

#### 성능 최적화

- Bloom filter
  - 존재하지 않는 키를 찾는 경우 멤테이블을 확인한 후 가장 오래된 세그먼트까지 거슬러 올라가야 하기 때문에 느릴 수 있다. 이럴 때 블룸 필터를 추가적으로 사용함으로서 접근을 최적화 할 수 있다.
  - 키가 데이터베이스에 존재하지 않음을 알려주어 키를 위한 디스크 읽기를 많이 절약할 수 있다.
- SS테이블 압축과 병합 시기를 결정하는 전략
  - size-tiered
    - HBase
    - 상대적으로 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합
  - leveled tiered
    - 레벨DB, 록스DB
    - 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하여 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용
- LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
  - 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 여전히 효과적. 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 실행할 수 있다. 
  - 디스크 쓰기가 순차적이기 때문에 높은 쓰기 처리량을 보장할 수 있다.

### B 트리

- 가장 널리 사용되는 색인 구조
- 키로 정렬된 키-값 쌍을 유지한다는 것이 거의 유일한 SS테이블과의 공통점
- 로그 구조화 색인
  - 데이터베이스를 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 순차적으로 세그먼트를 기록
- B 트리
  - 전통적으로 4KB(때로는 더 큰)의 고정 크기의 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기
- 주소나 위치를 이용해 각 페이지를 식별 (포인터와 비슷하지만 메모리 대신 디스크에 있다.)
- 한 페이지는 B 트리의 root로 지정된다. 색인에서 키를 찾으려면 루트에서 시작한다.
  - 페이지는 여러 키와 하위 페이지의 참조를 포함한다. 각 하위 페이지는 키가 계속 이어지는 범위를 담당하고, 참조 사이의 키는 해당 범위 경계가 어디인지를 나타낸다.
- 최종적으로는 개별 키 (leaf page)를 포함하는 페이지에 도달한다.
- 한 페이지에서 하위 페이지를 참조하는 수를 분기 계수(branching factor)라고 한다.
- 키의 값을 갱신하려면 키를 포함하고 있는 leaf page를 검색하고 페이지의 값을 바꾼 다음 페이지를 다시 디스크에 기록한다.(페이지에 대한 모든 참조는 계속 유효하다)
- 새로운 키를 추가하려면 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다.
  - 페이지에 공간이 없을 경우 페이지 하나를 반 정도 채워진 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신한다.
  - 이 알고리즘은 트리가 균형을 유지하는 것을 보장한다. n개의 키를 가진 B트리는 깊이가 항상 `O(logn)` 이다.

### 신뢰할 수 있는 B 트리 만들기

- B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓴다. 이 동작은 덮어쓰기가 페이지의 위치를 변경하지 않는다고 가정한다. 즉, 페이지를 덮어쓰더라도 페이지를 가리키는 모든 참조는 온전하게 남는다. 이는 파일에 추가만 할 뿐 같은 위치의 파일은 변경하지 않는 LSM 트리와 같은 로그 구조화 색인과 다른 점이다.
- 디스크의 페이지를 덮어쓰는 일은 실제 하드웨어 동작이라고 생각할 수 있다.
- 일부 동작은 여러 페이지의 덮어쓰기를 필요로 한다. 예를 들어 새로운 키를 추가하려는데 페이지에 공간이 없을 경우 페이지를 분할하고 상위 페이지에서 분할된 페이지를 참조할 수 있도록 갱신해야 하는데, 일부 페이지에서 데이터베이스가 고장날 경우 orphan page가 발생할 수 있다.
- 데이터베이스가 고장 상황에서 스스로 복구할 수 있으려면 WAL(write-ahead log, 쓰기전 로그 redo log, 재실행 로그)라고 하는 데이터 구조를 추가해 B트리를 구현한다. WAL은 트리 페이지에 변경된 내용을 적용하기 전 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일이다. 이 로그는 데이터베이스가 고장 이후 복구될 때 일관성 있는 상태로 B트리를 복원하는데 사용된다.
- 동시성 제어는 래치(latch)로 트리의 데이터 구조를 보호한다.
  - 로그 구조화 접근 방식은 훨씬 간단하다. 유입 질의의 간섭 없이 백그라운드에서 모든 병합을 수행하고 이따금 원자적으로 새로운 세그먼트를 이전 세그먼트로 바꾸기 때문이다.


### B 트리 최적화

- 페이지 덮어 쓰기와 WAL 유지 대신 일부 데이터 베이스는 copy-on-write scheme를 사용한다. 
- 페이지에 전체 키를 저장하는 게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다.
- 페이지는 디스크 상 어디에나 위치할 수 있다.
- 트리에 포인터를 추가한다.
- 디스크 찾기를 줄이기 위한 fractal tree

## B 트리와 LSM 트리 비교

### LSM 트리의 장점

- B 트리 색인은 WAL에 한 번, 트리 페이지에 한번 최소 두번 데이터를 기록해야 한다.
- 로그 구조화 색인 또한 SS 테이블의 반복된 컴팩션과 병합으로 인해 여러 번 데이터를 다시 쓴다.
- 쓰기 증폭 (write amplification)
  - DB에 쓰기 한 번이 DB 수명 동안 디스크에 여러 번의 쓰기를 야기하는 효과
  - SSD는 수명이 다할 때까지 블록 덮어쓰기 횟수가 제한되어 쓰기 증폭은 SSD의 경우 특별한 관심사다.
- 쓰기가 많은 애플리케이션에서 성능 병목은 데이터베이스가 디스크에 쓰는 속도일 수 있다. 이 경우 쓰기 증폭은 성능 비용이다. 저장소 엔진이 디스크에 기록할 수록 디스크 대역폭 내 처리할 수 있는 초당 쓰기는 점점 줄어든다.
- LSM 트리가 상대적으로 쓰기 증폭이 더 낮고 트리에서 여러 페이지를 덮어 쓰는 것이 아니라 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문에 B 트리 보다 쓰기 처리량을 높게 유지할 수 있다.
- LSM 트리가 압축률이 더 좋아 B 트리보다 디스크에 더 적은 파일을 생성한다. B 트리는 파편화로 인해 디스크 공간 일부가 남는 반면, LSM 트리는 주기적으로 파편화를 없애기 위해 SS테이블에 다시 기록하여 저장소 오버헤드가 낮다. 레벨 컴팩션을 사용하면 특히 그렇다.

### LSM 트리의 단점

- 로그 구조화 저장소의 단점은 컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다는 점이다. 저장소 엔진은 컴팩션을 점진적으로 수행하고 동시 접근의 영향이 없게 수행하려 하지만 디스크가 가진 자원은 한계가 있고, 디스크에서 비싼 컴팩션이 끝날 때 까지 대기해야 하는 상황이 발생하기 쉽다. 
- 또 다른 컴팩션 문제는 높은 쓰기 처리량에서 발생한다. 쓰기 처리량이 높음에도 컴팩션 설정을 주의깊게 하지 않으면 컴팩션이 유입쓰기 속도를 따라갈 수 없고 디스크 상에 병합되지 않은 세그먼트 수가 디스크 공간이 부족할때 까지 증가한다. 그러면 더 많은 세그먼트 파일을 확인해야 하기 때문에 읽기 또한 느려진다. 보통 SS테이블 기반 저장소 엔진은 이런 상황을 감지하기 위한 명시적인 모니터링이 필요하다.
- B 트리의 장점은 각 키가 색인의 한 곳에만 정확하게 존재한다는 것이다. 반면 로그 구조화 저장소 엔진의 경우 여러 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다. 이런 측면 때문에 강력한 트랜잭션 시맨틱을 제공하는 데이터베이스에는 B 트리가 훨씬 매력적이다.
- 사용 사례에 적합한 저장소 엔진의 유형을 결정하기 위해 테스트를 통해 경험적으로 결정하는 방법도 나쁘지 않다.
