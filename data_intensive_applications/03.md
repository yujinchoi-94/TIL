# 03장 저장소와 검색

특정 workload 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 알아야 할 필요가 있다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- append only 데이터 파일 log
  - 여기서의 로그는 일반적인 의미로 연속된 추가 전용 레코드이다. 로그는 사람이 읽을 수 없는 바이너리 형식일 수도 있다.
- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 색인이 필요하다.
  - 색인은 부가적인 메타데이터를 유지하여 원하는 데이터의 위치를 찾는데 도움을 주는 이정표 역할을 한다.
  - 동일한 데이터를 여러 방법으로 찾고 싶다면 다양한 색인이 필요하다.
- 색인은 기본 데이터에서 파생된 추가적인 구조이다. 색인의 추가와 삭제는 데이터베이스의 내용에는 영향을 끼치지는 않지만 성능에는 영향을 끼친다.
  - 색인을 쓰는 과정에서 오버헤드가 발생하고, 데이터를 쓸 때 마다 색인을 갱신해야 하기 때문이다.
- 색인은 저장소 시스템의 중요한 트레이드 오프이다. 따라서 개발자와 데이터베이스 관리자는 전형적인 질의 패턴에 대한 지식을 활용해 수동ㅇ으로 색인을 선택해야 한다.

### 해시색인

- K-V 데이터는 매우 일반적이고 더욱 복잡한 색인을 위한 구성요소로 유용하다.
- K-V 저장소는 대부분의 프로그래밍 언어에 존재하는 dictionary type과 유사하다. 디스크상의 데이터를 색인하기 위해 인메모리 데이터 구조인 해시맵을 사용해보면 어떨까?
  - 키를 데이터 파일의 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략을 가질 수 있다. 
  - 파일에 새로운 K-V 쌍을 추가할 때 마다 방금 기록한 데이터의 오프셋을 반영하기 위해 해시맵도 갱신해야 한다. 
  - 값을 조회하려면 해시 맵을 사용해 데이터파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
- 이 방법은 단순해보이지만 실제로 많이 사용된다. Bitcask(Riak의 기본 저장소 엔진)이 근본적으로 사용하는 방식이다. 
  - Bitcask는 해시 맵을 전무 메모리에 유지하여 RAM에 모든 키가 저장된다는 것을 전제 조건으로 고성능의 읽기/쓰기를 보장한다. 
  - 이러한 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다. 쓰기가 아주 많지만 고유키가 많지 않은 경우에 유용하다. 즉, 키당 쓰기 수가 많지만 메모리에 모든 키를 보관할 수 있다.
- 지금 설명한대로 항상 디스크에 파일을 추가하다보면 결국 디스크 공간이 부족해진다. 이 상황은 특정 크기의 segment로 로그를 나누어 해결할 수 있다. 특정 크기에 도달했을 때 세그먼트 파일을 닫고 새로운 세그먼트에 이후 쓰기를 수행한다. 세그먼트에 대해 컴팩션을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.
- 컴팩션은 보통 세그먼트를 더 작게 만들어 동시에 여러 세그먼트를 합칠 수 있다. 세그먼트는 쓰여진 이후에 절대로 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만든다. 고정된 세그먼트의 병합과 컴팩션은 백그라운드에서 수행될 수 있고, 컴팩션이 수행되는 동안 이전 세그먼트 파일을 사용하여 읽기와 쓰기 요청을 정상적으로 처리할 수 있다. 병합이 끝난 이후 읽기 요청은 이전 세그먼트 대신 새로 병합된 세그먼트 파일을 사용하도록 전환한다. 전환 후에는 이전 세그먼트 파일을 간단히 삭제 한다.
- 이제 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다. 키의 값을 찾으려면 최신 세그먼트 해시 맵을 먼저 확인하고, 키가 없을 경우 두 번째, 세번째 최신 세그먼트를 확인한다. 병합 과정을 통해 세그먼트 수를 적게 유지하여 조회할 때 많은 해시 맵을 확인할 필요가 없다.
- 하지만 이런 간단한 생각을 구현하기 위해서는 실제로 많은 사항을 고려해야 한다. 예를 들면 다음과 같다.
  - 파일 형식
  - 레코드 삭제
  - Crash 복구
    - DB 재시작시 인메모리 해시맵은 손실된다. 복구하려면 전체 세그먼트 파일을 읽어 각 키에 대한 최신 값으로 해시맵을 복원할 수 있지만, 세그먼트 파일이 큰 경우 복원이 오래 걸릴 수 있다.
  - 부분적으로 레코드 쓰기
  - 동시성 제어
    - 쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적인 구현 방법은 하나의 쓰기 쓰레드만 사용하는 것이다. 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기를 할 수 있다.
- 해시 테이블 색인의 제한 사항
  - 해시 테이블을 메모리에 저장해야 하기 때문에 키가 너무 많을 경우 문제가 된다.
  - range query에 효율적이지 않다. 예를 들어 `kitty0000`과 `kitty9999`  사이 모든 키를 쉽게 스캔 할 수 없다. 해시 맵에서 모든 개별 키를 조회해야 한다.
  - 다음에서 이러한 제한이 없는 색인 구조를 살펴보자

### SS테이블과 LSM 트리

- Sorted String Table (SST, SS테이블)
  - 세그먼트 파일이 키로 정렬된 형식
  - 각 키는 병합된 세그먼트 파일에 반드시 한 번만 나타나야 한다. (컴팩션 과정은 이를 이미 보장한다.)
- SST는 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.
  - 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. 이 방법은 mergesort와 유사하다.
  - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다. 일부 키에 대한 오프셋을 알려주는 인메모리 색인이 여전히 필요하지만 색인 내용이 드문드문 희소할 수 있다.
  - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다. 그러면 희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 된다. 디스크 공간을 절약한다는 점 외에도 압축은 I/O 대역폭 사용도 줄인다.

#### SS테이블 생성과 유지

- Red Black Tree나 AVL 트리와 같은 잘 알려진 구조를 이용하여 정렬된 메모리를 유지 할 수 있다. 이런 데이터 구조를 이용하여 임의 순서로 키를 삽입하고 정렬된 순서로 키를 다시 읽을 수 있다.
- 이제 저장소 엔진을 다음과 같이 만들 수 있다.
  - 쓰기 발생시 인메모리 balanced tree 데이터 구조에 추가한다. 이 인메모리 balanced tree를 memtable이라고도 한다.
  - memtable이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS 테이블 파일로 디스크에 기록한다. 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록한다.
  - 읽기 요청을 제공할 때 먼저 멤테이블에서 키를 찾고 그 다음 디스크 상의 가장 최신 세그먼트에서 찾는다. 그 다음으로 두번째, 세번째 세그먼트 등에서 찾는다.
  - 가끕 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다.
- 위 계획은 데이터베이스가 고장났을 때 멤테이블에 존재하지만 디스크에 기록되지 않은 쓰기가 손실된다는 문제가 있다. 이런 문제를 피하기 위해 매번 쓰기를 즉시 추가할 수 있는 분리된 로그를 디스크 상에 유지해야 한다. 이 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 정렬되지 않아도 괜찮다. 멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.

#### SS테이블에서 LSM 트리 만들기

- 이 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree)(AKA LSM Tree) 란 이름으로 발표됐다. 이 색인 구조는 로그 구조화 파일 시스템의 초기 작업 기반이 됐다.
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다.
- 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진 루씬은 용어 사전을 저장하기 위해 이와 유사한 방법을 사용한다.
  - 키를 단어(용어)로, 값은 단어를 포함한 모든 문서의 ID 목록으로 하는 키-값 구조로 표현한다. 루씬에서 용어와 포스팅의 목록은 SS테이블 같은 정렬 파일에 유지하고 필요에 따라 백그라운드에서 병합한다.

#### 성능 최적화

- Bloom filter
  - 존재하지 않는 키를 찾는 경우 멤테이블을 확인한 후 가장 오래된 세그먼트까지 거슬러 올라가야 하기 때문에 느릴 수 있다. 이럴 때 블룸 필터를 추가적으로 사용함으로서 접근을 최적화 할 수 있다.
  - 키가 데이터베이스에 존재하지 않음을 알려주어 키를 위한 디스크 읽기를 많이 절약할 수 있다.
- SS테이블 압축과 병합 시기를 결정하는 전략
  - size-tiered
    - HBase
    - 상대적으로 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합
  - leveled tiered
    - 레벨DB, 록스DB
    - 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하여 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용
- LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
  - 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 여전히 효과적. 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 실행할 수 있다. 
  - 디스크 쓰기가 순차적이기 때문에 높은 쓰기 처리량을 보장할 수 있다.

### B 트리

- 가장 널리 사용되는 색인 구조
- 키로 정렬된 키-값 쌍을 유지한다는 것이 거의 유일한 SS테이블과의 공통점
- 로그 구조화 색인
  - 데이터베이스를 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 순차적으로 세그먼트를 기록
- B 트리
  - 전통적으로 4KB(때로는 더 큰)의 고정 크기의 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기
- 주소나 위치를 이용해 각 페이지를 식별 (포인터와 비슷하지만 메모리 대신 디스크에 있다.)
- 한 페이지는 B 트리의 root로 지정된다. 색인에서 키를 찾으려면 루트에서 시작한다.
  - 페이지는 여러 키와 하위 페이지의 참조를 포함한다. 각 하위 페이지는 키가 계속 이어지는 범위를 담당하고, 참조 사이의 키는 해당 범위 경계가 어디인지를 나타낸다.
- 최종적으로는 개별 키 (leaf page)를 포함하는 페이지에 도달한다.
- 한 페이지에서 하위 페이지를 참조하는 수를 분기 계수(branching factor)라고 한다.
- 키의 값을 갱신하려면 키를 포함하고 있는 leaf page를 검색하고 페이지의 값을 바꾼 다음 페이지를 다시 디스크에 기록한다.(페이지에 대한 모든 참조는 계속 유효하다)
- 새로운 키를 추가하려면 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다.
  - 페이지에 공간이 없을 경우 페이지 하나를 반 정도 채워진 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신한다.
  - 이 알고리즘은 트리가 균형을 유지하는 것을 보장한다. n개의 키를 가진 B트리는 깊이가 항상 `O(logn)` 이다.



