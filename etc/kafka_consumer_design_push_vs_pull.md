# Kafka Consumer Design : Push vs Pull

카프카는 프로듀서가 브로커로 메시지를 푸시하고 컨슈머가 메시지를 가져가는 Pull 기반 시스템이다.

- Scribe, Apache Flume과 같은 시스템은 반대로 데이터를 다운스트림으로 푸시하는 시스템

## Push 시스템의 단점

- Push 기반의 시스템은 브로커가 데이터가 전송 속도를 조절할 수 있기 때문에 여러 컨슈머를 다루는데 어려움이 있다.
- 일반적으로 컨슈머가 가능한 최대의 속도로 메시지를 컨슈밍 하는 것이 목표이다.
- 하지만, push 시스템에서는 컨슈머는 컨슈밍 속도가 프로덕션 속도를 따라잡지 못하는 경향이 있다.(특히 DoS 과 같은 경우)



## Pull 시스템의 장점

- Pull 기반의 시스템은 컨슈머가 메시지를 컨슈밍하는 속도가 뒤쳐지더라도 나중에 따라잡으면 된다는 장점이 있다. 
  - 뒤쳐지는 것은 lag를 통해 알 수 있다.

- 데이터를 batching 역할을 컨슈머가 한다.
  - Push 기반의 시스템은 요청을 즉시 보내거나 혹은 다운스트림 컨슈머가 즉시 처리할 수 있을지 무관하게 데이터를 모았다가 나중에 전송한다. 낮은 레이턴시를 위해 설정되어 한번에 하나의 메시지만 보내게 되면 결국 데이터는 단지 전송만을 위해 버퍼 되어 있게 되고 이는 낭비로 이어진다.
  - Pull 기반의 시스템은 컨슈머가 로그의 현재 포지션 이후에 모든 가능한 메시지들을 가져가기 때문에 이러한 문제점을 해결한다. 따라서 불필요한 레이턴시 없이도 최적화된 배칭 효과를 얻을 수 있다.



## 카프카는 Pull 시스템의 단점을 어떻게 극복했을까?

- 브로커에 아무런 데이터가 없을 경우 컨슈머가 데이터가 도착하는 것을 기다리며 tight loop polling을 하게 될 수 있다.
- 이런 문제를 막기 위해 pull 요청에는 데이터가 도착할 때까지 기다리는 "long poll"에서 컨슈머 요청을 막을 수 있는 파라미터가 있다.



## end-to-end Pull 시스템은 어떨까?

- 프로듀서는 로컬 로그에 write를 하고, 브로커는 이를 가져가고, 컨슈머는 브로커에서 가져간다.
  - 유사한 유형으로 "store-and-forward" 프로듀서가 종종 제안된다
- 흥미롭지만 수천개의 프로듀서가 존재할 수 있는 카프카의 유즈케이스에는 적합하지 않다.
  - 큰 규모로 영구 데이터 시스템을 운영하는 경험은 여러 애플리케이션에 걸친 시스템 내의 수천개의 디스크에 관여하는 것과 같은 기분을 느끼게 했고, 실제로 시스템을 더 신뢰할 수 있게 하지 않았고 운영을 어렵게만 했다. 
  - 그리고 실제로 프로듀서의 persistence 없이도 큰 규모에서 강력한 SLA로 파이프라인을 운영할 수 있다는 것을 발견했다.



> 원문 : https://kafka.apache.org/documentation/#design_pull

